# Intermediate code, generated by INTECTRIO from template file:
# c:/program files (x86)/etas/intecrio5.0/build/common/tools/pi_core-4.6/templates/instances_usercode.tpl
# DO NOT EDIT!

def output(file, str)
    file.write(str + "\n")
end

def make(node)
node_stack = []
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='USR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.h", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.h")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for arbitrary user code or INCODIO")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2024 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, "/* Model initialization function prototype */")
output(file, "extern struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initModel_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void);")
output(file, "/* Level 1 class object declaration */")
output(file, "extern struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassObj;")
output(file, "/* Level 1 class initialization function prototype */")
output(file, "extern void initClass_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class *class);")
output(file, "/* Level 1 object instantiation function prototype */")
output(file, "extern struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void);")
output(file, "/* Function prototype for module specific setDeltaT() */")
output(file, "void setDeltaT_#{node.node_table[:id]}(void);")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "extern struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class #{node.node_table[:coder]}_#{node.node_table[:id]}_ClassObj;")
output(file, "extern void initClass_#{node.node_table[:coder]}_#{node.node_table[:id]}(struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class *self);")
output(file, "extern struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}_#{node.node_table[:id]}(void);")
    end
end
node = node_stack.pop()
output(file, "/* Definition of the class structure */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
output(file, "#ifndef __TEMPLATE_CODE_INCLUDE__ /* Included from external. */")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    void *#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr;")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    void *#{node.node_table[:coder]}_#{node.node_table[:id]}_Ptr;")
    end
end
node = node_stack.pop()
output(file, "#else /*__TEMPLATE_CODE_INCLUDE__*/")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    #{node.node_table[:type]}Wrapper_Obj *#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr;")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *#{node.node_table[:coder]}_#{node.node_table[:id]}_Ptr;")
    end
end
node = node_stack.pop()
output(file, "#endif /*__TEMPLATE_CODE_INCLUDE__*/")
output(file, "};")
output(file, "/* Definition of the class object structure */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
output(file, "};")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    #{node.node_table[:type]}Wrapper_Obj *#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr;")
    end
end
node = node_stack.pop()
output(file, "};")
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
output(file, "};")
    end
end
node = node_stack.pop()
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='USR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.c", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.c")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for arbitrary user code or INCODIO")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2024 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, " /* use void* as instance tree wrapper object pointer type */")
output(file, " #define Y_PRIMIT_VOID_PTR_FOR_ADDR")
node_stack.push(node)
unless(node.node_table[:inclst].nil?)
    node.node_table[:inclst].each() do
        |entry| 
        node = entry
output(file, "#include \"#{node.node_table[:hdrfile]}\"")
    end
end
node = node_stack.pop()
output(file, "#include \"../a_basdef.h\"")
output(file, "#define __TEMPLATE_CODE_INCLUDE__")
output(file, "#include \"#{node.node_table[:name]}_instances.h\"")
output(file, "#undef __TEMPLATE_CODE_INCLUDE__")
output(file, "#ifndef __WRAPPER_CODE_SKIP_BASESTRUCT_EXTDECL__")
node_stack.push(node)
unless(node.node_table[:declst].nil?)
    node.node_table[:declst].each() do
        |entry| 
        node = entry
output(file, "extern #{node.node_table[:typeref]} #{node.node_table[:basedef]} #{node.node_table[:dimensions]};")
    end
end
node = node_stack.pop()
output(file, "#endif")
output(file, "/* Initialization of Simulink model */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initModel_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "    struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *model;")
output(file, "    /* Level 1 class initialization */")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    initClass_#{node.node_table[:coder]}_#{node.node_table[:id]} (&#{node.node_table[:coder]}_#{node.node_table[:id]}_ClassObj);")
    end
end
node = node_stack.pop()
output(file, "    initClass_#{node.node_table[:coder]}Top_#{node.node_table[:id]} (&#{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassObj);")
output(file, "    /* Level 1 object instantiation */")
output(file, "    model = initInstance_#{node.node_table[:coder]}Top_#{node.node_table[:id]}();")
output(file, "    return(model);")
output(file, "}")
output(file, "/* Class initialization */")
output(file, "void initClass_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class *self)")
output(file, "{")
output(file, "    /* Level 1 class variables */")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:typeid]==1)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==2)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width]}, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==3)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width_x]}, (uint32)#{node.node_table[:width_y]}, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==4)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var_ref1]}, sizeof(#{node.node_table[:cdt_ref1]}), (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==5)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var_ref1]}, sizeof(#{node.node_table[:cdt_ref1]}), (void*)&#{node.node_table[:var_ref2]}, sizeof(#{node.node_table[:cdt_ref2]}), (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width_ref1]}, (uint32)#{node.node_table[:width_ref2]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==6)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper(&self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname_ref1]}_Ptr, (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==7)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper(&self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname_ref1]}_Ptr, &self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname_ref2]}_Ptr, (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width_ref1]}, (uint32)#{node.node_table[:width_ref2]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    self->#{node.node_table[:coder]}_#{node.node_table[:id]}_Ptr = initInstance_#{node.node_table[:coder]}_#{node.node_table[:id]}();")
    end
end
node = node_stack.pop()
output(file, "    return;")
output(file, "}")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "void initClass_#{node.node_table[:coder]}_#{node.node_table[:id]}(struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class *self)")
output(file, "{")
output(file, "    /* Level 2 class variables */")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:typeid]==1)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==2)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width]}, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==3)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width_x]}, (uint32)#{node.node_table[:width_y]}, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==4)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var_ref1]}, sizeof(#{node.node_table[:cdt_ref1]}), (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==5)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:var_ref1]}, sizeof(#{node.node_table[:cdt_ref1]}), (void*)&#{node.node_table[:var_ref2]}, sizeof(#{node.node_table[:cdt_ref2]}), (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width_ref1]}, (uint32)#{node.node_table[:width_ref2]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==6)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper(&self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname_ref1]}_Ptr, (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:typeid]==7)
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper(&self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname_ref1]}_Ptr, &self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname_ref2]}_Ptr, (void*)&#{node.node_table[:var]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:width_ref1]}, (uint32)#{node.node_table[:width_ref2]}, (uint32)INTERPOLATE_LINEAR, (uint32)EXTRAPOLATE_CONST, (uint32)#{node.node_table[:kind]});")
end
    end
end
node = node_stack.pop()
output(file, "}")
    end
end
node = node_stack.pop()
output(file, "static uint8 * _L1_getPid_#{node.node_table[:id]}(ASDObjectPtr self, uint8 *buffer)")
output(file, "{")
output(file, "    uint8 definedFlg = true;")
output(file, "    uint32 programIdentifier = 0;")
output(file, "    if(definedFlg == true)")
output(file, "    {")
output(file, "        addScalar(buffer, (uint8*)&programIdentifier, sizeof(programIdentifier));")
output(file, "    }")
output(file, "    addScalar(buffer, (uint8*)&definedFlg, sizeof(definedFlg));")
output(file, "    return(buffer);")
output(file, "}")
output(file, "/* Class method list */")
output(file, "static MethodList #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassMethodList =")
output(file, "{")
output(file, "    (MethodPtr)_L1_getPid_#{node.node_table[:id]}")
output(file, "};")
output(file, "/* Definition of the class header */")
output(file, "static ASDClassHeader #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassHeader =")
output(file, "    {0, 1, 0, #{node.node_table[:objlst].nil? ? 0 : node.node_table[:objlst].size} + #{node.node_table[:cntrlst].nil? ? 0 : node.node_table[:cntrlst].size}, (MethodList *)0, (MethodList *)&#{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassMethodList};")
output(file, "/* Definition and initialization of the class object */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassObj = {{1, {&#{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassHeader}, {0}}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    ,NULL")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    ,NULL")
    end
end
node = node_stack.pop()
output(file, "};")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "static ASDClassHeader #{node.node_table[:coder]}_#{node.node_table[:id]}_ClassHeader =")
output(file, "    {0, 0, 0, #{node.node_table[:objlst].nil? ? 0 : node.node_table[:objlst].size}, (MethodList *)0, (MethodList *) 0};")
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class #{node.node_table[:coder]}_#{node.node_table[:id]}_ClassObj = {{1, {&#{node.node_table[:coder]}_#{node.node_table[:id]}_ClassHeader}, {0}}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    ,NULL")
    end
end
node = node_stack.pop()
output(file, "};")
    end
end
node = node_stack.pop()
output(file, "/* Object instantiation */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "    struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *self;")
output(file, "    /* Object instantiation / Implicit memory allocation */")
output(file, "    CREATE_OBJECT(self, #{node.node_table[:coder]}Top_#{node.node_table[:id]});")
output(file, "    return self;")
output(file, "}")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "    struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *self;")
output(file, "    /* Object instantiation / Implicit memory allocation */")
output(file, "    CREATE_OBJECT(self, #{node.node_table[:coder]}_#{node.node_table[:id]});")
output(file, "    return self;")
output(file, "}")
    end
end
node = node_stack.pop()
output(file, "void setDeltaT_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "}")
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='USR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_externs.h", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_externs.h")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for arbitrary user code or INCODIO")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2024 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, "#ifdef _USE_GENERATED_DECLARATIONS_")
if(node.node_table[:name]!='EDC_MsgAdapter')
if(node.node_table[:name]!='OSMonitoring')
output(file, "#include \"Rte_Type.h\"")
end
end
         genIds = Array.new

         last_prm = String.new ""

         last_prm_typeqfr = String.new ""

         last_prm_signedness = String.new ""

         last_prm_cdt = String.new ""

         last_prm_count = 0

node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
         node.node_table[:idExists] = genIds.include?(node.node_table[:id])

if(!node.node_table[:idExists])
         genIds.push(node.node_table[:id])

if(!node.node_table[:id].include?('.'))
         node.node_table[:last_prm] = String.new last_prm

         node.node_table[:last_prm_typeqfr] = String.new last_prm_typeqfr

         node.node_table[:last_prm_signedness] = String.new last_prm_signedness

         node.node_table[:last_prm_cdt] = String.new last_prm_cdt

         node.node_table[:last_prm_count] = last_prm_count

if(!node.node_table[:last_prm].empty?)
         node.node_table[:generate_line] = false

if(node.node_table[:typeid]==1&&!node.node_table[:id].include?('['))
         node.node_table[:generate_line] = true

elsif(node.node_table[:typeid]!=1)
         node.node_table[:generate_line] = true

end
if(node.node_table[:generate_line])
output(file, "extern #{node.node_table[:last_prm_typeqfr]} #{node.node_table[:last_prm_signedness]} #{node.node_table[:last_prm_cdt]} #{node.node_table[:last_prm]}[#{node.node_table[:last_prm_count]}]; //measure prm")
         node.node_table[:last_prm] = String.new ""

         node.node_table[:last_prm_count] = 0

end
end
if(node.node_table[:typeid]==1)
if(node.node_table[:id].include?('['))
         node.node_table[:start_par] = node.node_table[:id].rindex('[')

         node.node_table[:var_name] = node.node_table[:id][0..(node.node_table[:start_par]-1)]

if(node.node_table[:last_prm].empty?)
         node.node_table[:last_prm] = String.new node.node_table[:var_name]

         node.node_table[:last_prm_count] = 1

         node.node_table[:last_prm_typeqfr] = String.new node.node_table[:typeqfr]

         node.node_table[:last_prm_signedness] = String.new node.node_table[:signedness]

         node.node_table[:last_prm_cdt] = String.new node.node_table[:cdt]

elsif(node.node_table[:var_name]==node.node_table[:last_prm])
         node.node_table[:last_prm_count] = node.node_table[:last_prm_count] + 1

elsif(node.node_table[:var_name]!=node.node_table[:last_prm])
output(file, "extern #{node.node_table[:last_prm_typeqfr]} #{node.node_table[:last_prm_signedness]} #{node.node_table[:last_prm_cdt]} #{node.node_table[:last_prm]}[#{node.node_table[:last_prm_count]}]; //measure prm")
         node.node_table[:last_prm] = String.new node.node_table[:var_name]

         node.node_table[:last_prm_count] = 1

         node.node_table[:last_prm_typeqfr] = String.new node.node_table[:typeqfr]

         node.node_table[:last_prm_signedness] = String.new node.node_table[:signedness]

         node.node_table[:last_prm_cdt] = String.new node.node_table[:cdt]

end
end
if(!node.node_table[:id].include?('['))
output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:cdt]} #{node.node_table[:id]}; //type 1 ")
end
         last_prm = String.new node.node_table[:last_prm]

         last_prm_typeqfr = String.new node.node_table[:last_prm_typeqfr]

         last_prm_signedness = String.new node.node_table[:last_prm_signedness]

         last_prm_cdt = String.new node.node_table[:last_prm_cdt]

         last_prm_count = node.node_table[:last_prm_count]

end
if(node.node_table[:typeid]==2)
if(node.node_table[:id].scan(/\[/).count)
output(file, "//#{node.node_table[:id]} is prm of type 2")
end
if(node.node_table[:id].scan(/\[/).count)
output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:cdt]} #{node.node_table[:id]}[#{node.node_table[:width]}]; //type 2")
end
         last_prm = String.new node.node_table[:last_prm]

         last_prm_typeqfr = String.new node.node_table[:last_prm_typeqfr]

         last_prm_signedness = String.new node.node_table[:last_prm_signedness]

         last_prm_cdt = String.new node.node_table[:last_prm_cdt]

         last_prm_count = node.node_table[:last_prm_count]

end
if(node.node_table[:typeid]==3)
output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:cdt]} #{node.node_table[:id]}[#{node.node_table[:width_x]}][#{node.node_table[:width_y]}]; //type 3")
end
if(node.node_table[:typeid]==4)
         node.node_table[:id1Exists] = genIds.include?(node.node_table[:id_ref1])

if(!node.node_table[:id1Exists])
         genIds.push(node.node_table[:id_ref1])

output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:ctype_ref1]} #{node.node_table[:id_ref1]}[#{node.node_table[:width]}]; //type 4 id1")
end
output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:cdt]} #{node.node_table[:id]}[#{node.node_table[:width]}]; //type 4")
end
if(node.node_table[:typeid]==5)
         node.node_table[:id1Exists] = genIds.include?(node.node_table[:id_ref1])

if(!node.node_table[:id1Exists])
         genIds.push(node.node_table[:id_ref1])

output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:ctype_ref1]} #{node.node_table[:id_ref1]}[#{node.node_table[:width_ref1]}]; //type 5 id1")
end
         node.node_table[:id2Exists] = genIds.include?(node.node_table[:id_ref2])

if(!node.node_table[:id2Exists])
         genIds.push(node.node_table[:id_ref2])

output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:ctype_ref2]} #{node.node_table[:id_ref2]}[#{node.node_table[:width_ref2]}]; //type 5 id2")
end
output(file, "extern #{node.node_table[:typeqfr]} #{node.node_table[:signedness]} #{node.node_table[:cdt]} #{node.node_table[:id]}[#{node.node_table[:width_ref1]}][#{node.node_table[:width_ref2]}]; //type 5")
end
end
end
    end
end
node = node_stack.pop()
output(file, "#endif")
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='USR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.lst", "w")
output(file, "_MID_ ; #{node.node_table[:id]}")
output(file, "_MNAME_ ; #{node.node_table[:name]}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "#{node.node_table[:id]} ; #{node.node_table[:addr]} ; #{node.node_table[:kind]} ; #{node.node_table[:modpath]} ; #{node.node_table[:ecu_addr]}")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "#{node.node_table[:id]} ; #{node.node_table[:parent_addr]} #{node.node_table[:addr]} ; #{node.node_table[:kind]} ; #{node.node_table[:modpath]} ; #{node.node_table[:ecu_addr]}")
    end
end
node = node_stack.pop()
    end
end
node = node_stack.pop()
file.close()
end
end
    end
end
node = node_stack.pop()
# <EOF>

end
