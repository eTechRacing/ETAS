# Intermediate code, generated by INTECTRIO from template file:
# c:/program files (x86)/etas/intecrio5.0/build/common/tools/pi_core-4.6/templates/instances_ascet-rp.tpl
# DO NOT EDIT!

def output(file, str)
    file.write(str + "\n")
end

def make(node)
node_stack = []
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='ASCET_RP')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.h", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.h")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for ETAS ASCET-RP")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2007 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, "#define initModel_#{node.node_table[:coder]}Top_#{node.node_table[:id]} initModel_ASCETTop#{node.node_table[:delta_t_id]}")
output(file, "#define setDeltaT_#{node.node_table[:id]} setDeltaT#{node.node_table[:delta_t_id]}")
output(file, "/* ASCET init function prototype */")
output(file, "extern ASDObject *initModel_#{node.node_table[:coder]}Top_#{node.node_table[:id]} (void);")
output(file, "/* ASCET setDeltaT function prototype */")
output(file, "void setDeltaT_#{node.node_table[:id]} (void);")
output(file, "/* Definition of the class object structure */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
output(file, "};")
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='ASCET_RP')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.c", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.c")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for ETAS ASCET-RP")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2007 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, "/* This file is empty, because the instance tree is provided by ASCET */")
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='ASCET_RP')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.lst", "w")
output(file, "_MID_ ; #{node.node_table[:id]}")
output(file, "_MNAME_ ; #{node.node_table[:name]}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "#{node.node_table[:modid]} ; ; #{node.node_table[:kind]} ; #{node.node_table[:modpath]} ; #{node.node_table[:ecu_addr]}")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "#{node.node_table[:modid]} ; ; #{node.node_table[:kind]} ; #{node.node_table[:modpath]} ; #{node.node_table[:ecu_addr]}")
    end
end
node = node_stack.pop()
    end
end
node = node_stack.pop()
file.close()
end
end
    end
end
node = node_stack.pop()
# <EOF>

end
