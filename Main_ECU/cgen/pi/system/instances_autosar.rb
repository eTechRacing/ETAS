# Intermediate code, generated by INTECTRIO from template file:
# c:/program files (x86)/etas/intecrio5.0/build/common/tools/pi_core-4.6/templates/instances_autosar.tpl
# DO NOT EDIT!

def output(file, str)
    file.write(str + "\n")
end

def make(node)
node_stack = []
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='AUTOSAR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.h", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.h")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for AUTOSAR software components")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2007 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, "/* Model initialization function prototype */")
output(file, "extern struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initModel_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void);")
output(file, "/* Level 1 class object declaration */")
output(file, "extern struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassObj;")
output(file, "/* Level 1 class initialization function prototype */")
output(file, "extern void initClass_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class *class);")
output(file, "/* Level 1 object instantiation function prototype */")
output(file, "extern struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void);")
output(file, "/* Function prototype for module specific setDeltaT() */")
output(file, "void setDeltaT_#{node.node_table[:id]}(void);")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "extern struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class #{node.node_table[:coder]}_#{node.node_table[:id]}_ClassObj;")
output(file, "extern void initClass_#{node.node_table[:coder]}_#{node.node_table[:id]}(struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class *self);")
output(file, "extern struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}_#{node.node_table[:id]}(void);")
    end
end
node = node_stack.pop()
output(file, "/* Definition of the class structure */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    #{node.node_table[:type]}Wrapper_Obj *#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr;")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *#{node.node_table[:coder]}_#{node.node_table[:id]}_Ptr;")
    end
end
node = node_stack.pop()
output(file, "};")
output(file, "/* Definition of the class object structure */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
output(file, "};")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    #{node.node_table[:type]}Wrapper_Obj *#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr;")
    end
end
node = node_stack.pop()
output(file, "};")
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj")
output(file, "{")
output(file, "    ASDObjectHeader objectHeader;")
output(file, "};")
    end
end
node = node_stack.pop()
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='AUTOSAR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.c", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.c")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for AUTOSAR software components")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2007 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, " /* use void* as instance tree wrapper object pointer type */")
output(file, " #define Y_PRIMIT_VOID_PTR_FOR_ADDR")
output(file, "/* Do not clash with potentially available platform headers */")
output(file, "#ifdef CONST")
output(file, "#undef CONST")
output(file, "#endif")
output(file, "#include \"../a_basdef.h\"")
output(file, "#include \"#{node.node_table[:name]}_instances.h\"")
node_stack.push(node)
unless(node.node_table[:inclst].nil?)
    node.node_table[:inclst].each() do
        |entry| 
        node = entry
output(file, "#include \"#{node.node_table[:hdrfile]}\"")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:declst].nil?)
    node.node_table[:declst].each() do
        |entry| 
        node = entry
output(file, "extern #{node.node_table[:typeref]} #{node.node_table[:basedef]};")
    end
end
node = node_stack.pop()
output(file, "/* Proxy data elements for measurement */")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:typeid]==1)
if(node.node_table[:kind]=="ASD_VARIABLE")
output(file, "#{node.node_table[:cdt]} #{node.node_table[:modname]}_proxy_#{node.node_table[:id]} = #{node.node_table[:objlst].nil? ? 0 : node.node_table[:objlst].size}; /* initialize to defined value */")
end
end
    end
end
node = node_stack.pop()
output(file, "/* Initialization of Simulink model */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initModel_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "    struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *model;")
output(file, "    /* Level 1 class initialization */")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    initClass_#{node.node_table[:coder]}_#{node.node_table[:id]} (&#{node.node_table[:coder]}_#{node.node_table[:id]}_ClassObj);")
    end
end
node = node_stack.pop()
output(file, "    initClass_#{node.node_table[:coder]}Top_#{node.node_table[:id]} (&#{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassObj);")
output(file, "    /* Level 1 object instantiation */")
output(file, "    model = initInstance_#{node.node_table[:coder]}Top_#{node.node_table[:id]}();")
output(file, "    return(model);")
output(file, "}")
output(file, "/* Class initialization */")
output(file, "void initClass_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class *self)")
output(file, "{")
output(file, "    /* Level 1 class variables */")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:typeid]==1)
if(node.node_table[:kind]=="ASD_PARAMETER")
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:modpath]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:kind]});")
end
if(node.node_table[:kind]=="ASD_VARIABLE")
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:modname]}_proxy_#{node.node_table[:id]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:kind]});")
end
end
    end
end
node = node_stack.pop()
output(file, "    return;")
output(file, "}")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "void initClass_#{node.node_table[:coder]}_#{node.node_table[:id]}(struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class *self)")
output(file, "{")
output(file, "    /* Level 2 class variables */")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:typeid]==1)
if(node.node_table[:kind]=="ASD_PARAMETER")
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:modpath]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:kind]});")
elsif(node.node_table[:kind]=="ASD_VARIABLE")
output(file, "    self->#{node.node_table[:coder]}Wrapper_#{node.node_table[:cname]}_Ptr = initInstance_#{node.node_table[:type]}Wrapper((void*)&#{node.node_table[:modname]}_proxy_#{node.node_table[:id]}, sizeof(#{node.node_table[:cdt]}), (uint32)#{node.node_table[:kind]});")
end
end
    end
end
node = node_stack.pop()
output(file, "}")
    end
end
node = node_stack.pop()
output(file, "static uint8 * _L1_getPid_#{node.node_table[:id]}(ASDObjectPtr self, uint8 *buffer)")
output(file, "{")
output(file, "    uint8 definedFlg = true;")
output(file, "    uint32 programIdentifier = 0;")
output(file, "    if(definedFlg == true)")
output(file, "    {")
output(file, "        addScalar(buffer, (uint8*)&programIdentifier, sizeof(programIdentifier));")
output(file, "    }")
output(file, "    addScalar(buffer, (uint8*)&definedFlg, sizeof(definedFlg));")
output(file, "    return(buffer);")
output(file, "}")
output(file, "/* Class method list */")
output(file, "static MethodList #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassMethodList =")
output(file, "{")
output(file, "    (MethodPtr)_L1_getPid_#{node.node_table[:id]}")
output(file, "};")
output(file, "/* Definition of the class header */")
output(file, "static ASDClassHeader #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassHeader =")
output(file, "    {0, 1, 0, #{node.node_table[:objlst].nil? ? 0 : node.node_table[:objlst].size} + #{node.node_table[:cntrlst].nil? ? 0 : node.node_table[:cntrlst].size}, (MethodList *)0, (MethodList *)&#{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassMethodList};")
output(file, "/* Definition and initialization of the class object */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Class #{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassObj = {{1, {&#{node.node_table[:coder]}Top_#{node.node_table[:id]}_ClassHeader}, {0}}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    ,NULL")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "    ,NULL")
    end
end
node = node_stack.pop()
output(file, "};")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "static ASDClassHeader #{node.node_table[:coder]}_#{node.node_table[:id]}_ClassHeader =")
output(file, "    {0, 0, 0, #{node.node_table[:objlst].nil? ? 0 : node.node_table[:objlst].size}, (MethodList *)0, (MethodList *) 0};")
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Class #{node.node_table[:coder]}_#{node.node_table[:id]}_ClassObj = {{1, {&#{node.node_table[:coder]}_#{node.node_table[:id]}_ClassHeader}, {0}}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "    ,NULL")
    end
end
node = node_stack.pop()
output(file, "};")
    end
end
node = node_stack.pop()
output(file, "/* Object instantiation */")
output(file, "struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}Top_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "    struct #{node.node_table[:coder]}Top_#{node.node_table[:id]}_Obj *self;")
output(file, "    /* Object instantiation / Implicit memory allocation */")
output(file, "    CREATE_OBJECT(self, #{node.node_table[:coder]}Top_#{node.node_table[:id]});")
output(file, "    return self;")
output(file, "}")
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
output(file, "struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *initInstance_#{node.node_table[:coder]}_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "    struct #{node.node_table[:coder]}_#{node.node_table[:id]}_Obj *self;")
output(file, "    /* Object instantiation / Implicit memory allocation */")
output(file, "    CREATE_OBJECT(self, #{node.node_table[:coder]}_#{node.node_table[:id]});")
output(file, "    return self;")
output(file, "}")
    end
end
node = node_stack.pop()
output(file, "void setDeltaT_#{node.node_table[:id]}(void)")
output(file, "{")
output(file, "}")
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='AUTOSAR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.lst", "w")
output(file, "_MID_ ; #{node.node_table[:id]}")
output(file, "_MNAME_ ; #{node.node_table[:name]}")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "#{node.node_table[:id]} ; #{node.node_table[:addr]} ; #{node.node_table[:kind]} ; #{node.node_table[:modpath]} ; #{node.node_table[:ecu_addr]}")
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlst].nil?)
    node.node_table[:cntrlst].each() do
        |entry| 
        node = entry
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
output(file, "#{node.node_table[:id]} ; #{node.node_table[:parent_addr]} #{node.node_table[:addr]} ; #{node.node_table[:kind]} ; #{node.node_table[:modpath]}")
    end
end
node = node_stack.pop()
    end
end
node = node_stack.pop()
file.close()
end
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:active])
if(node.node_table[:coder]=='AUTOSAR')
file = File.new("#{node.node_table[:outdir]}/#{node.node_table[:name]}_instances.a2l", "w")
output(file, "/*****************************************************************************")
output(file, " *")
output(file, " * #{node.node_table[:name]}_instances.a2l")
output(file, " *")
output(file, " * Part of INTECRIO Simulation Interface for AUTOSAR software components")
output(file, " *")
output(file, " * Generated by INTECRIO Project Integrator, do not edit!")
output(file, " *")
output(file, " * Copyright 2007 ETAS (ETAS GmbH)")
output(file, " *")
output(file, " *****************************************************************************/")
output(file, "ASAP2_VERSION  1 41   /* Version 1.41 */")
output(file, "/begin PROJECT #{node.node_table[:id]}")
output(file, "    \"INTECRIO PICORE generated ASAM-MCD-2MC description file fragment for AUTOSAR software component #{node.node_table[:name]}\"")
output(file, "    /begin HEADER")
output(file, "        \" \"")
output(file, "    /end HEADER")
output(file, "    /begin MOD_PAR")
output(file, "        \" \"")
output(file, "    /end MOD_PAR")
output(file, "    /begin MOD_COMMON")
output(file, "        \"BYTE_ORDER: Motorola = MSB_FIRST, Intel = MSB_LAST\"")
output(file, "        BYTE_ORDER MSB_FIRST")
output(file, "    /end MOD_COMMON")
output(file, "    /begin MODULE #{node.node_table[:id]}")
output(file, "        \"SWC_#{node.node_table[:name]}\"")
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:kind]=="ASD_VARIABLE")
output(file, "        /begin MEASUREMENT")
output(file, "          /* Name */                    #{node.node_table[:id]}")
output(file, "          /* Long identifier */         \"#{node.node_table[:id]} (#{node.node_table[:modname]}_proxy_#{node.node_table[:id]})\"")
output(file, "          /* Data type */               #{node.node_table[:a2ldt]}")
output(file, "          /* Conversion method */       COMPU_METHOD_LINEAR")
output(file, "          /* Resolution (Not used) */   0")
output(file, "          /* Accuracy (Not used) */     0")
output(file, "          /* Lower limit */             -9.99999999E+307")
output(file, "          /* Upper limit */             9.99999999E+307")
output(file, "          /begin IF_DATA E_TARGET")
output(file, "            KP_BLOB 0xFFFFFFFF 0xFFFFFFFF #{node.node_table[:addr]}")
output(file, "         /end IF_DATA")
output(file, "        /end MEASUREMENT")
end
if(node.node_table[:kind]=="ASD_PARAMETER")
output(file, "        /begin CHARACTERISTIC")
output(file, "          /* Name               */             #{node.node_table[:id]}")
output(file, "          /* Long Identifier    */             \"\"")
output(file, "          /* Type               */             VALUE")
output(file, "          /* Memory Address     */             0x0")
output(file, "          /* Record Layout      */             Scalar_#{node.node_table[:a2ldt]}")
output(file, "          /* Maximum Difference */             0 ")
output(file, "          /* Conversion Method  */             COMPU_METHOD_LINEAR")
output(file, "          /* Lower Limit        */             -9.99999999E+307")
output(file, "          /* Upper Limit        */             9.99999999E+307")
output(file, "          DISPLAY_IDENTIFIER                   AUTOSAR.#{node.node_table[:modname]}.#{node.node_table[:modpath]}")
output(file, "          /begin IF_DATA E_TARGET")
output(file, "            DP_BLOB 0xFFFFFFFF 0xFFFFFFFF #{node.node_table[:addr]}")
output(file, "         /end IF_DATA")
output(file, "        /end CHARACTERISTIC")
output(file, "        /begin RECORD_LAYOUT Scalar_#{node.node_table[:a2ldt]}")
output(file, "            FNC_VALUES 1 #{node.node_table[:a2ldt]} COLUMN_DIR DIRECT")
output(file, "        /end RECORD_LAYOUT")
end
    end
end
node = node_stack.pop()
node_stack.push(node)
unless(node.node_table[:cntrlist].nil?)
    node.node_table[:cntrlist].each() do
        |entry| 
        node = entry
node_stack.push(node)
unless(node.node_table[:objlst].nil?)
    node.node_table[:objlst].each() do
        |entry| 
        node = entry
if(node.node_table[:kind]=="ASD_VARIABLE")
output(file, "        /begin MEASUREMENT")
output(file, "          /* Name */                    #{node.node_table[:id]}")
output(file, "          /* Long identifier */         \"#{node.node_table[:id]} (#{node.node_table[:modname]}_proxy_#{node.node_table[:id]})\"")
output(file, "          /* Data type */               #{node.node_table[:a2ldt]}")
output(file, "          /* Conversion method */       COMPU_METHOD_LINEAR")
output(file, "          /* Resolution (Not used) */   0")
output(file, "          /* Accuracy (Not used) */     0")
output(file, "          /* Lower limit */             -9.99999999E+307")
output(file, "          /* Upper limit */             9.99999999E+307")
output(file, "          /begin IF_DATA E_TARGET")
output(file, "            KP_BLOB 0xFFFFFFFF 0xFFFFFFFF #{node.node_table[:parent_addr]} #{node.node_table[:addr]}")
output(file, "         /end IF_DATA")
output(file, "        /end MEASUREMENT")
elsif(node.node_table[:kind]=="ASD_PARAMETER")
output(file, "        /begin CHARACTERISTIC")
output(file, "          /* Name               */             #{node.node_table[:id]}")
output(file, "          /* Long Identifier    */             \"\"")
output(file, "          /* Type               */             VALUE")
output(file, "          /* Memory Address     */             0x0")
output(file, "          /* Record Layout      */             Scalar_#{node.node_table[:a2ldt]}")
output(file, "          /* Maximum Difference */             0 ")
output(file, "          /* Conversion Method  */             COMPU_METHOD_LINEAR")
output(file, "          /* Lower Limit        */             -9.99999999E+307")
output(file, "          /* Upper Limit        */             9.99999999E+307")
output(file, "          DISPLAY_IDENTIFIER                   AUTOSAR.#{node.node_table[:modname]}.#{node.node_table[:modpath]}")
output(file, "          /begin IF_DATA E_TARGET")
output(file, "            DP_BLOB 0xFFFFFFFF 0xFFFFFFFF #{node.node_table[:parent_addr]} #{node.node_table[:addr]}")
output(file, "         /end IF_DATA")
output(file, "        /end CHARACTERISTIC")
output(file, "        /begin RECORD_LAYOUT Scalar_#{node.node_table[:a2ldt]}")
output(file, "            FNC_VALUES 1 #{node.node_table[:a2ldt]} COLUMN_DIR DIRECT")
output(file, "        /end RECORD_LAYOUT")
end
    end
end
node = node_stack.pop()
    end
end
node = node_stack.pop()
output(file, "        /begin COMPU_METHOD")
output(file, "          /* Name of CompuMethod */     COMPU_METHOD_LINEAR")
output(file, "          /* Long identifier */         \"Q = V\"")
output(file, "          /* Conversion Type */         RAT_FUNC")
output(file, "          /* Format */                  \"%0.6f\"")
output(file, "          /* Units */                   \"\"")
output(file, "          /* Coefficients */            COEFFS 0 1 0 0 0 1")
output(file, "        /end COMPU_METHOD")
output(file, "    /end MODULE")
output(file, "/end PROJECT")
file.close()
end
end
    end
end
node = node_stack.pop()
# <EOF>

end
